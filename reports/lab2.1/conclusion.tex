\section{Conclusion}

\subsection{Achievement of Objectives}

All primary objectives of Laboratory Work 2.1 were successfully accomplished. A functional non-preemptive bare-metal task scheduler was designed and implemented as a reusable library, correctly dispatching exactly one task per scheduler tick based on deadline comparison. The button debounce FSM reliably distinguishes short and long presses, producing accurate duration measurements in milliseconds even under noisy mechanical contact conditions (50\,ms confirmation window). Visual feedback operates correctly: the green and red LEDs illuminate for the appropriate press type, and the yellow LED produces exactly 5 or 10 blinks as specified. The periodic STDIO reporting mechanism delivers a formatted statistics summary every 10 seconds and resets accumulators to start a fresh measurement window.

\subsection{Performance Analysis and System Limitations}

The compiled firmware is compact, occupying approximately 6.7\,KB of Flash (2.7\,\%) and 800 bytes of SRAM (9.8\,\%) on the ATmega2560, leaving ample room for future expansion. The scheduler overhead per tick is negligible: one linear sweep of a three-element array executing in a few microseconds, which is imperceptible relative to the 10\,ms Task 1 period. The round-trip latency from button release to visual confirmation is bounded by one Task 1 period plus one Task 2 period — at most 60\,ms — undetectable by human perception.

The main limitation of the cooperative scheduling model is shared by all bare-metal cooperative designs: if any task function blocks or executes for longer than its period, all subsequent tasks are delayed accordingly. In this application, all three tasks are short and bounded, so this is not a concern in practice. However, the \texttt{printf()} call in Task 3 imposes a small serialisation cost proportional to the output string length over a 9600 baud link (approximately 5\,ms for 6 lines at 9600 baud), which is acceptable given the 10\,s reporting interval. Another limitation is the integer division used for average duration: for a small number of presses with large individual durations, the integer truncation error is negligible, but it would require floating-point arithmetic for sub-millisecond precision.

\subsection{Proposed Improvements}

Several enhancements would strengthen the application. Adding a configurable press threshold (via STDIO command) would allow the user to tune the 500\,ms boundary at runtime rather than requiring a recompile. The statistics window could be made configurable as well, since 10\,s may be too short for slow manual testing or too long for high-frequency automated testing. The average duration calculation could be extended to maintain a running minimum and maximum in addition to the mean, giving the user a better characterisation of press duration distribution. For safety-critical deployments, a watchdog timer that resets the MCU if no task runs within a configurable interval would protect against task runaway. Finally, the statistics could be stored in EEPROM so that the press history survives a power cycle.

\subsection{Reflections on the Learning Experience}

This laboratory work provided concrete insight into how a minimal scheduling framework transforms a monolithic \texttt{loop()} into a structured set of cooperating tasks. Writing the scheduler from first principles reinforced the importance of absolute-time advancement (\texttt{nextRun += period}) over relative-time scheduling (\texttt{nextRun = millis() + period}), which accumulates drift over hundreds of ticks. The button FSM exercise highlighted how a seemingly simple user interaction — pressing a button — requires careful state management to be robust against mechanical noise. The inter-task communication pattern (one producer, one consumer, one resetter operating on shared volatile variables without locks) is a practical template applicable to a wide class of embedded sensing applications.

\subsection{Impact of Technology in Real-World Applications}

Cooperative bare-metal scheduling is the dominant design pattern in cost-sensitive, power-constrained, and safety-certifiable embedded products. The approach demonstrated here appears in automotive ECUs (Electronic Control Units), industrial PLCs, medical wearable devices, and consumer electronics. In automotive applications, the AUTOSAR OS specification defines cooperative and preemptive scheduling categories; many low-cost ECUs use cooperative scheduling exclusively. In medical devices, the absence of an RTOS simplifies certification under IEC 62304 because the scheduler is small, fully deterministic, and easy to review. The button-duration classification technique is directly applicable to user interaction in HVAC control panels, medical device menus, and industrial machinery where different press durations trigger different actions without requiring multiple physical buttons.
