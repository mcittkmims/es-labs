\section{Conclusion}

\subsection{Achievement of Objectives}

All primary objectives of Laboratory Work 1.2 were successfully accomplished. The I2C communication protocol was used to interface a 16x2 LCD display with the Arduino Mega 2560, enabling clear visual feedback through context-aware menu displays, password masking, and confirmation messages. The 4x4 matrix keypad was integrated with 20ms software debouncing for reliable key detection, using the asterisk (\texttt{*}) as a field delimiter and hash (\texttt{\#}) as a command executor. A 10-state finite state machine was designed and implemented to manage the complete lock system logic --- including unconditional locking, password-based unlocking, password changes with verification, and status queries --- with clean separation between the FSM service and hardware drivers. The modular software architecture follows a five-layer design (APP, SRV, ECAL, MCAL, HW) where two library modules from Lab~1.1 (Led, StdioSerial) are reused without modification, and three new modules (LcdDisplay, KeypadInput, LockFSM) extend the library collection. Lab isolation is maintained through PlatformIO's multi-environment build system with preprocessor-based lab selection, ensuring all previous labs remain fully functional.

\subsection{Performance Analysis and System Limitations}

The system performs well within its design parameters. The non-blocking main loop achieves sub-millisecond cycle times, providing input-to-display latency well below the 100ms requirement. Memory usage is efficient at 22.6\% RAM and 4.4\% Flash, leaving substantial headroom for additional features. The keypad debouncing reliably filters contact bounce while maintaining responsive input.

However, the system has several limitations. The password is stored in volatile SRAM and resets to the default ``1234'' on every power cycle or reset, as there is no EEPROM persistence. The maximum password length is limited to 8 digits, and passwords can only contain numeric characters (0--9), reducing the keyspace. The system does not implement lockout protection after multiple failed unlock attempts, which would be essential in a real security application. The LCD's 16-character line width constrains message length, requiring abbreviated text in some states. The FSM uses blocking \texttt{printf()} calls for debug output, which could introduce minor latency in the serial transmission path (though this is negligible at 9600 baud for short messages).

\subsection{Proposed Improvements}

Several enhancements could address the current limitations and extend functionality. EEPROM password persistence would retain the password across power cycles by storing it in the ATmega2560's 4~KB EEPROM. A failed attempt counter with exponential lockout (e.g., 30-second lockout after 3 failed attempts, doubling with each subsequent failure) would significantly improve security. Alphanumeric password support using the keypad's A--D keys would expand the keyspace from $10^8$ to $14^8$ combinations. An audible buzzer could provide additional feedback for key presses, successful operations, and error conditions. A real-time clock module could enable time-based access control (automatic lock/unlock schedules) and event logging with timestamps. Multi-user support with separate passwords for different access levels (admin for password changes, user for unlock only) would add practical utility. Finally, a timeout mechanism in the FSM's intermediate states would automatically return to IDLE if no key is pressed within a configurable period, preventing the system from remaining in a half-entered command state indefinitely.

\subsection{Reflections on the Learning Experience}

This laboratory work provided valuable experience in several key areas of embedded systems development. Designing the 10-state FSM required careful planning of all possible state transitions, including error conditions and edge cases, which reinforced the importance of thorough upfront design before implementation. The FSM pattern proved extremely effective for managing complex interactive behavior --- each state's logic is self-contained and independently testable, making debugging straightforward.

The transition from Lab~1.1's blocking I/O model (\texttt{fgets()} waiting for complete input) to Lab~1.2's non-blocking event-driven model (\texttt{getKey()} returning immediately) highlighted a fundamental design pattern in embedded systems: responsive user interfaces require cooperative multitasking where each task voluntarily yields control quickly. This concept scales directly to professional embedded firmware where multiple subsystems must share a single CPU.

Working with the I2C protocol demonstrated the power of standardized communication buses --- connecting the LCD required only two signal wires and a well-established library, compared to the 12+ wires that would be needed for a parallel interface. The experience of wrapping third-party libraries behind project-specific interfaces (LcdDisplay wrapping LiquidCrystal\_I2C, KeypadInput wrapping Keypad) illustrated the adapter pattern, which isolates application code from library-specific APIs and makes future library replacements straightforward.

\subsection{Impact of Technology in Real-World Applications}

The keypad-plus-LCD interface pattern implemented in this lab is among the most widely deployed human-machine interfaces in embedded systems. Security panels from manufacturers like DSC, Honeywell, and Bosch use nearly identical command protocols where \texttt{*} accesses function menus and \texttt{\#} confirms operations. ATM machines use numeric keypads with LCD displays for PIN entry and transaction selection, employing the same password masking technique demonstrated here. Industrial equipment (CNC machines, PLCs, HVAC controllers) commonly uses membrane keypads with character LCDs for parameter configuration and status monitoring.

The FSM architecture used in this lab directly maps to the state machine designs used in professional security and access control systems, where deterministic state transitions and comprehensive error handling are essential for reliable operation. The modular software architecture (with hardware drivers separated from application logic through abstraction layers) reflects the AUTOSAR methodology used in automotive embedded systems, where standardization of software components enables reuse across different vehicle platforms and hardware variants.
