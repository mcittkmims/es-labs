\section{Domain Analysis}

\subsection{Objective of the Laboratory Work}

The objective of this laboratory work is to familiarize students with the use of the C Standard I/O (STDIO) library for serial communication in embedded systems. The primary goal is to design and implement a simple application on an Arduino Mega 2560 microcontroller that controls an LED through text commands transmitted from a serial terminal.

The key learning objectives include understanding the fundamental principles of serial communication (UART protocol), using the STDIO library functions (\texttt{printf}, \texttt{fgets}) for text-based data exchange over a serial interface, designing an application that interprets commands received through the serial port, and developing a modular software solution with separate reusable components for each peripheral device.

\subsection{Problem Definition}

The task requires the development of a microcontroller-based application with the following functional requirements:

\begin{enumerate}
    \item Configure the application to use the STDIO library through the serial interface for text exchange via a terminal emulator.
    \item Design and implement a command interpreter that receives commands from the serial terminal:
    \begin{itemize}
        \item \texttt{led on} --- turns the LED ON.
        \item \texttt{led off} --- turns the LED OFF.
    \end{itemize}
    \item The system must respond with text confirmation messages for each processed command.
    \item All text input/output must be handled using the C STDIO library (\texttt{printf}, \texttt{fgets}, etc.), not Arduino-specific \texttt{Serial.print()} calls at the application level.
    \item The application must be structured in a modular fashion, with separate files for each peripheral (LED, serial I/O).
\end{enumerate}

\subsection{Used Technologies}

\subsubsection{UART Serial Communication}

UART (Universal Asynchronous Receiver-Transmitter) is a hardware communication protocol that enables asynchronous serial data exchange between two devices. In this laboratory, UART is used to establish communication between the Arduino Mega 2560 and a host PC running a serial terminal application.

UART communication is asynchronous, meaning there is no shared clock signal between transmitter and receiver; both sides must agree on a common baud rate (9600 in this lab). It operates in full-duplex mode, allowing data to be transmitted and received simultaneously over two separate lines (TX and RX). The frame format consists of a start bit, 8 data bits, an optional parity bit, and one or more stop bits. UART is also a point-to-point protocol, connecting exactly two devices directly.

Asynchronous data transmission occurs at the frame level, each having a specific structure as shown in \citeimg{fig:uart_frame}. At the protocol level, UART defines several key communication parameters: baud rate (transfer speed), data bits (typically 8 bits per frame), parity (for error detection), and stop bits (to mark frame boundaries). A commonly encountered standard configuration is 9600 baud, 8 data bits, no parity, and 1 stop bit (abbreviated as 9600 8N1).

\begin{figure}[H]
\centering
\includegraphics[width=0.85\textwidth]{resources/DomainAnalysis/UsedTechnologies/uart_frame.png}
\caption{UART serial transmission frame structure}
\label{fig:uart_frame}
\end{figure}

On the Arduino Mega 2560, UART0 is connected to the USB-to-Serial converter chip, allowing seamless communication with the host PC over a USB cable.

\subsubsection{C Standard I/O Library (STDIO)}

The C Standard I/O library (\texttt{<stdio.h>}) provides portable, high-level functions for formatted text input and output. In desktop environments, these functions interact with console I/O; in embedded systems, they can be redirected to any I/O peripheral.

The key STDIO functions used in this lab are \texttt{printf()}, which provides formatted text output to \texttt{stdout} for displaying prompts, confirmation messages, and error messages, and \texttt{fgets()}, which reads a line of text from \texttt{stdin} to capture user commands from the serial terminal.

On AVR microcontrollers with the Arduino framework, STDIO streams (\texttt{stdout}, \texttt{stdin}) are not connected to any device by default. The AVR libc library provides the \texttt{fdev\_setup\_stream()} function to create custom FILE streams backed by user-defined read/write functions. By assigning a custom stream to \texttt{stdout} and \texttt{stdin}, all subsequent calls to \texttt{printf()} and \texttt{fgets()} are transparently redirected to the serial port.

\subsubsection{PlatformIO Build System}

PlatformIO is a professional open-source ecosystem for embedded development. It provides project management, library dependency resolution, multi-board support, and integrated build/upload/monitor tools. In this lab, PlatformIO is used within VS Code to compile, upload, and monitor the application on the Arduino Mega 2560.

\subsubsection{Wokwi Simulator}

Wokwi is an online and VS Code-integrated simulator for embedded systems. It supports Arduino, ESP32, and other popular platforms. Wokwi allows testing of the application in a virtual environment before deploying to physical hardware, providing a simulated serial terminal and virtual LEDs.

\begin{figure}[H]
\centering
\includegraphics[width=0.6\textwidth]{resources/DomainAnalysis/SoftwareComponents/wokwi.png}
\caption{Example of circuit simulation in Wokwi with Arduino and LED}
\label{fig:wokwi_simulation}
\end{figure}

In this laboratory work, Wokwi is integrated with PlatformIO through a configuration file (\texttt{wokwi.toml}). This integration allows the compiled firmware to be executed in the simulator for testing and verification without physical hardware, as shown in \citeimg{fig:wokwi_simulation}.

\subsection{Hardware Components}

\subsubsection{Arduino Mega 2560}

The Arduino Mega 2560 is a microcontroller development board based on the ATmega2560 AVR chip. It features 54 digital I/O pins (15 of which support PWM output), 16 analog inputs, 4 hardware UART ports, a 16 MHz crystal oscillator, a USB connection, a power jack, and an ICSP header.

\begin{figure}[H]
\centering
\includegraphics[width=0.7\textwidth]{resources/DomainAnalysis/HardwareComponents/arduino_mega_2560.png}
\caption{Arduino Mega 2560 development board with AVR architecture}
\label{fig:arduino_mega}
\end{figure}

The Arduino Mega 2560 board, shown in \citeimg{fig:arduino_mega}, uses an ATmega2560 microcontroller based on the AVR architecture. This 8-bit RISC processor operates at 16 MHz. Key specifications relevant to this lab:

\begin{itemize}
    \item \textbf{Microcontroller:} ATmega2560 (8-bit AVR, 16 MHz)
    \item \textbf{Flash memory:} 256 KB (8 KB used by bootloader)
    \item \textbf{SRAM:} 8 KB
    \item \textbf{Digital I/O pins:} 54
    \item \textbf{UART ports:} 4 (UART0 connected to USB)
    \item \textbf{Operating voltage:} 5V
    \item \textbf{I/O pin output current:} 20 mA (max 40 mA)
\end{itemize}

UART0 (pins 0/TX and 1/RX) is connected through a USB-to-Serial converter chip, enabling direct communication with the host PC for programming and serial monitoring.

\subsubsection{LED (Light-Emitting Diode)}

A standard 5mm red LED is used as the output actuator in this lab. The LED is connected to digital pin 7 of the Arduino Mega through a current-limiting resistor. When pin 7 is set HIGH (5V), current flows through the resistor and LED, causing it to emit light. When set LOW (0V), the LED turns off.

\begin{figure}[H]
\centering
\includegraphics[width=0.15\textwidth]{resources/DomainAnalysis/HardwareComponents/led.png}
\caption{Electrical connection circuit of the LED to the microcontroller}
\label{fig:led_component}
\end{figure}

LED specifications:

\begin{itemize}
    \item \textbf{Forward voltage (Vf):} approximately 1.8--2.2V (red LED)
    \item \textbf{Forward current (If):} 20 mA (typical operating current)
    \item \textbf{Maximum current:} 30 mA
\end{itemize}

\subsubsection{220 $\Omega$ Resistor}

A 220~$\Omega$ resistor is placed in series with the LED to limit the current flowing through it. The resistor value is calculated based on Ohm's law:

$$I = \frac{V_{pin} - V_{LED}}{R} = \frac{5V - 2V}{220\,\Omega} \approx 13.6\,mA$$

This current is within the safe operating range of both the LED (< 20 mA) and the Arduino GPIO pin (< 40 mA absolute maximum).

\subsubsection{Breadboard and Jumper Wires}

A solderless breadboard provides a convenient prototyping platform for connecting the LED, resistor, and Arduino without soldering. Jumper wires are used to make electrical connections between the Arduino pins, the resistor, the LED, and the ground rail.

\subsection{Software Components}

\subsubsection{Visual Studio Code with PlatformIO}

Visual Studio Code (VS Code) is a lightweight but powerful source code editor. The PlatformIO IDE extension transforms it into a full-featured embedded development environment by providing project initialization and configuration via \texttt{platformio.ini}, automatic toolchain and library management, code compilation, firmware upload, and serial monitor capabilities, as well as IntelliSense code completion for Arduino/AVR libraries.

\begin{figure}[H]
\centering
\includegraphics[width=0.6\textwidth]{resources/DomainAnalysis/SoftwareComponents/platformio.png}
\caption{PlatformIO IDE extension in Visual Studio Code}
\label{fig:platformio_extension}
\end{figure}

For this project, PlatformIO IDE is used to configure the Arduino Mega 2560 development board, manage the project structure (including \texttt{src/}, \texttt{lib/}, and \texttt{include/} directories), and compile the source code targeting the ATmega2560 microcontroller. The \texttt{platformio.ini} configuration file specifies the board type, framework, and build settings, as shown in \citeimg{fig:platformio_extension}. PlatformIO handles the compilation, linking, and firmware upload process, while its library manager facilitates the integration of custom libraries such as the LED driver and STDIO serial service used in this application.

\subsubsection{Wokwi VS Code Extension}

The Wokwi VS Code extension enables hardware simulation directly within the IDE. It reads a \texttt{diagram.json} file defining the virtual circuit and a \texttt{wokwi.toml} file pointing to the compiled firmware. This allows interactive testing of the serial command interface without physical hardware.

\subsubsection{Serial Terminal (PlatformIO Monitor)}

PlatformIO's built-in serial monitor provides a terminal interface for sending and receiving text over the UART connection. It operates at a configurable baud rate (9600 in this lab) and displays characters received from the microcontroller while transmitting typed characters back to it.

\subsection{System Architecture and Justification}

The system follows a layered architecture that organizes functionality into distinct levels, each with specific responsibilities. This structure separates concerns and enables modular development. The APP (Application Layer) implements command processing logic and high-level functionalities. The SRV (Service Layer) provides common services such as command parsing and data formatting. The ECAL (ECU Abstraction Layer) abstracts platform-specific hardware details, including STDIO-to-UART redirection. The MCAL (Microcontroller Abstraction Layer) interfaces with microcontroller peripherals such as LED GPIO control. Finally, the HW (Hardware) layer represents the physical ATmega2560 microcontroller and its hardware peripherals.

This layered organization enables independent testing of components and allows modifications or extensions without affecting other system parts. The hardware-software interface operates across multiple abstraction layers, facilitating clear separation between application logic and hardware control.

\subsection{Case Study: Serial Command Interfaces in Embedded Systems}

Serial command-line interfaces (CLIs) are widely used in embedded systems for diagnostics, configuration, and debugging. Network equipment such as routers and switches (e.g., Cisco IOS, OpenWrt) use serial consoles for initial configuration and troubleshooting. Industrial PLCs (Programmable Logic Controllers) often accept serial commands for parameter tuning and status queries. IoT gateways typically provide serial debug interfaces for firmware updates and log inspection. Consumer devices like 3D printers use G-code commands over serial (typically UART) to control motion, temperature, and extrusion.

The STDIO-based approach demonstrated in this lab mirrors these real-world implementations, where a standardized text protocol enables human-machine interaction through a simple terminal connection. The modular architecture (separating I/O abstraction from application logic) is a fundamental pattern in professional embedded firmware development.
