\section{Design}

\subsection{System Architecture Diagrams}

\subsubsection{Component-Level Architecture}

The system consists of three main components: a host PC running a serial terminal, the Arduino Mega 2560 microcontroller, and the LED output circuit. The PC communicates with the MCU over a USB-to-UART bridge, sending text commands and receiving confirmation messages. The MCU processes these commands and drives the LED accordingly.

\begin{figure}[H]
\centering
\includegraphics[width=0.85\textwidth]{resources/Design/SystemArchitectureDiagrams/system_structural_diagram.png}
\caption{System structural diagram showing the PC, MCU, and LED circuit}
\label{fig:system_structural_diagram}
\end{figure}

The system structural diagram illustrates the data flow:

\begin{enumerate}
    \item The user types a command (e.g., \texttt{led on}) in the serial terminal on the PC.
    \item The command is transmitted over USB, converted to UART by the USB-to-Serial bridge on the Arduino board, and received by the ATmega2560's UART0 peripheral.
    \item The STDIO library redirects the incoming bytes to \texttt{stdin}, allowing \texttt{fgets()} to read the complete command line.
    \item The command parser module interprets the text and determines the action.
    \item The LED driver module sets the GPIO pin HIGH or LOW to control the LED.
    \item A confirmation message is sent back via \texttt{printf()} through \texttt{stdout}, which is redirected to UART TX, travels back over USB, and appears in the serial terminal.
\end{enumerate}

\subsubsection{Layered System Architecture}

The software follows a layered architecture that separates concerns:

\begin{figure}[H]
\centering
\includegraphics[width=0.75\textwidth]{resources/Design/SystemArchitectureDiagrams/layered_architecture.png}
\caption{Layered software architecture of the system}
\label{fig:layered_architecture}
\end{figure}

The software follows a layered architecture that separates concerns as illustrated in \citeimg{fig:layered_architecture}. The Application Layer (APP) contains \texttt{lab1\_1\_main}, which orchestrates the main control loop by prompting for input, reading commands, invoking the parser, executing LED actions, and displaying feedback. The Service Layer (SRV) contains \texttt{CommandParser}, which provides command interpretation as a reusable service that trims whitespace, normalizes case, and matches input strings against known commands. The ECU Abstraction Layer (ECAL) contains \texttt{StdioSerial}, which abstracts the UART hardware into C standard I/O streams by creating a bridge between the portable STDIO API and the Arduino Serial hardware. The Microcontroller Abstraction Layer (MCAL) contains the \texttt{Led} driver, which provides a clean object-oriented API for GPIO-based LED control, hiding direct \texttt{pinMode()}/\texttt{digitalWrite()} calls from upper layers. Finally, the Hardware (HW) layer consists of the physical ATmega2560 MCU with its UART0 peripheral (connected to USB) and digital GPIO pin 7 (connected to the LED circuit).

\subsection{Block Diagrams}

The application algorithm is divided into two phases: initialization and the main command loop.

\subsubsection{Initialization Phase}

During startup, the system configures the STDIO serial redirection (UART at 9600 baud, \texttt{stdout}/\texttt{stdin} redirected), initializes the LED driver (pin 7 as OUTPUT, LED OFF), and prints a welcome banner listing the available commands.

\begin{figure}[H]
\centering
\includegraphics[width=0.65\textwidth]{resources/Design/BlockDiagrams/flowchart_initialization.png}
\caption{Flowchart of the initialization phase}
\label{fig:flowchart_init}
\end{figure}

\subsubsection{Main Command Loop}

After initialization, the system enters an infinite loop: it displays a prompt, waits for a line from \texttt{stdin} (blocking \texttt{fgets()}), parses the command, executes the corresponding LED action, and prints a confirmation or error message.

\begin{figure}[H]
\centering
\includegraphics[width=0.65\textwidth]{resources/Design/BlockDiagrams/flowchart_main_loop.png}
\caption{Flowchart of the main command processing loop}
\label{fig:flowchart_main_loop}
\end{figure}

\subsection{Electrical Schematics}

The circuit is straightforward: a single red LED is connected in series with a 220~$\Omega$ current-limiting resistor between digital pin 7 of the Arduino Mega and ground.

\begin{figure}[H]
\centering
\includegraphics[width=0.65\textwidth]{resources/Design/ElectricalSchematics/electric_schema.png}
\caption{Electrical schematic --- LED control circuit}
\label{fig:circuit_schematic}
\end{figure}

\subsubsection{Component Specification}

The circuit consists of three main components. The Arduino Mega 2560 is a microcontroller board based on the ATmega2560 with 5V logic and a 16 MHz clock. It provides the digital GPIO output (pin 7) used to control the LED and the UART0 serial interface (connected via USB). A red LED with a 5mm diameter serves as the output indicator, with a forward voltage of approximately 2.0\,V and a maximum forward current rating of 20 mA. A 220~$\Omega$ resistor acts as the current-limiting component, reducing the LED current to approximately 13.6 mA at the 5V supply voltage.

\subsubsection{Circuit Connections}

The circuit forms a simple series path for current flow. Arduino Pin 7 connects to the first terminal of the 220~$\Omega$ resistor, with the GPIO output driving current through the resistor. The second resistor terminal connects to the LED anode (positive terminal), allowing current to flow from the resistor into the LED. The LED cathode (negative terminal) connects back to the Arduino ground, completing the circuit. When pin 7 outputs HIGH (5V), current $I = (5V - 2V) / 220\,\Omega \approx 13.6\,mA$ flows through the LED, illuminating it. When pin 7 outputs LOW (0V), no current flows and the LED is off.

\subsubsection{Hardware Configuration}

The Wokwi simulation implements the above circuit virtually. \citeimg{fig:wokwi_circuit} shows the assembled circuit in the Wokwi simulator.

\begin{figure}[H]
\centering
\includegraphics[width=0.65\textwidth]{resources/Design/ElectricalSchematics/wokwi_circuit.png}
\caption{Wokwi simulation circuit --- Arduino Mega 2560 with LED and 220~$\Omega$ resistor}
\label{fig:wokwi_circuit}
\end{figure}

The Wokwi simulation configuration file defines the virtual circuit:

\begin{lstlisting}[language=json, caption=Wokwi diagram.json --- Virtual circuit definition, label=lst:wokwi_diagram]
{
  "version": 1,
  "author": "Vremere Adrian",
  "editor": "wokwi",
  "parts": [
    {
      "type": "wokwi-arduino-mega",
      "id": "mega",
      "top": 0, "left": 0, "attrs": {}
    },
    {
      "type": "wokwi-resistor",
      "id": "r1",
      "top": -50, "left": 250, "rotate": 90,
      "attrs": { "resistance": "220" }
    },
    {
      "type": "wokwi-led",
      "id": "led1",
      "top": -120, "left": 240,
      "attrs": { "color": "red", "label": "LED1" }
    }
  ],
  "connections": [
    ["mega:7", "r1:1", "green", ["v0"]],
    ["r1:2", "led1:A", "green", ["v0"]],
    ["led1:C", "mega:GND.1", "black", ["v0"]]
  ]
}
\end{lstlisting}

\subsection{Project Structure}

The project follows a modular directory layout as required by the course conventions:

\begin{lstlisting}[caption=Project directory structure for Lab 1.1, label=lst:project_structure]
labs/
|-- platformio.ini              # Build config (env:lab1_1)
|-- src/
|   |-- main.cpp                # Entry point (lab selector)
|-- lab/
|   |-- lab1_1/
|       |-- lab1_1_main.h       # Lab 1.1 interface
|       |-- lab1_1_main.cpp     # Lab 1.1 implementation
|-- lib/
|   |-- Led/
|   |   |-- Led.h               # LED driver interface
|   |   |-- Led.cpp             # LED driver implementation
|   |-- StdioSerial/
|   |   |-- StdioSerial.h       # STDIO redirection interface
|   |   |-- StdioSerial.cpp     # STDIO redirection implementation
|   |-- CommandParser/
|       |-- CommandParser.h     # Command parser interface
|       |-- CommandParser.cpp   # Command parser implementation
|-- wokwi/
    |-- lab1.1/
        |-- diagram.json        # Wokwi circuit definition
        |-- wokwi.toml          # Wokwi firmware config
\end{lstlisting}

Each library under \texttt{lib/} is a self-contained, reusable module with a clear interface (\texttt{.h}) and implementation (\texttt{.cpp}). The lab-specific code resides in \texttt{lab/lab1\_1/}, while \texttt{src/main.cpp} simply delegates to the active lab's setup and loop functions.

\subsection{Modular Implementation}

\subsubsection{MCAL Layer: Led Driver}

The Led driver provides a hardware abstraction for controlling an LED connected to a GPIO pin. It encapsulates \texttt{pinMode()} and \texttt{digitalWrite()} behind a clean object-oriented interface.

\begin{lstlisting}[language=C++, caption=Led.h --- LED driver interface, label=lst:led_h]
#ifndef LED_H
#define LED_H

#include <Arduino.h>

class Led {
public:
    Led(uint8_t pin);
    void init();
    void turnOn();
    void turnOff();
    void toggle();
    bool isOn() const;
private:
    uint8_t ledPin;
    bool state;
};

#endif
\end{lstlisting}

\begin{lstlisting}[language=C++, caption=Led.cpp --- LED driver implementation, label=lst:led_cpp]
#include "Led.h"

Led::Led(uint8_t pin) : ledPin(pin), state(false) {}

void Led::init() {
    pinMode(ledPin, OUTPUT);
    digitalWrite(ledPin, LOW);
    state = false;
}

void Led::turnOn() {
    digitalWrite(ledPin, HIGH);
    state = true;
}

void Led::turnOff() {
    digitalWrite(ledPin, LOW);
    state = false;
}

void Led::toggle() {
    if (state) { turnOff(); }
    else { turnOn(); }
}

bool Led::isOn() const { return state; }
\end{lstlisting}

The \texttt{Led} class accepts a pin number at construction time, making it reusable for any GPIO-connected LED. The \texttt{init()} method must be called once during setup to configure the pin direction.

The \texttt{init()} function initializes the LED pin by configuring it as an output and setting the initial state to OFF, as illustrated in \citeimg{fig:flowchart_led_init}. The function ensures each LED is properly configured before application execution begins.

\begin{figure}[H]
\centering
\includegraphics[width=0.2\textwidth]{resources/Design/ModularImplementation/flowchart_led_init.png}
\caption{Flowchart: LED driver initialization}
\label{fig:flowchart_led_init}
\end{figure}

The \texttt{turnOn()} function's operational flow is shown in \citeimg{fig:flowchart_led_turnon}, demonstrating the GPIO state modification to illuminate the LED.

\begin{figure}[H]
\centering
\includegraphics[width=0.15\textwidth]{resources/Design/ModularImplementation/flowchart_led_turnon.png}
\caption{Flowchart: LED activation function}
\label{fig:flowchart_led_turnon}
\end{figure}

The \texttt{turnOff()} function operates symmetrically, setting the pin LOW and updating the state, as shown in \citeimg{fig:flowchart_led_turnoff}.

\begin{figure}[H]
\centering
\includegraphics[width=0.15\textwidth]{resources/Design/ModularImplementation/flowchart_led_turnoff.png}
\caption{Flowchart: LED deactivation function}
\label{fig:flowchart_led_turnoff}
\end{figure}

This driver demonstrates proper abstraction layer design: application code interacts with logical LED methods rather than physical pin numbers, hardware dependencies are isolated in the constructor, and the implementation remains independent of the specific pin assignments.

\subsubsection{ECAL Layer: StdioSerial}

The StdioSerial module redirects the C standard I/O streams (\texttt{stdout}, \texttt{stdin}) to the hardware UART, enabling the use of \texttt{printf()} and \texttt{fgets()} for serial communication.

\begin{lstlisting}[language=C++, caption=StdioSerial.h --- STDIO redirection interface, label=lst:stdio_serial_h]
#ifndef STDIO_SERIAL_H
#define STDIO_SERIAL_H

#include <Arduino.h>
#include <stdio.h>

void stdioSerialInit(unsigned long baudRate);

#endif
\end{lstlisting}

\begin{lstlisting}[language=C++, caption=StdioSerial.cpp --- STDIO redirection implementation (key sections), label=lst:stdio_serial_cpp]
#include "StdioSerial.h"

static int serialPutChar(char c, FILE *stream) {
    Serial.write(c);
    return 0;
}

static int serialGetChar(FILE *stream) {
    while (!Serial.available()) { }
    char c = Serial.read();
    if (c == '\r') {
        Serial.write('\r');
        Serial.write('\n');
        return '\n';
    }
    Serial.write(c); // Echo
    return c;
}

static FILE serialStream;

void stdioSerialInit(unsigned long baudRate) {
    Serial.begin(baudRate);
    while (!Serial) { ; }
    fdev_setup_stream(&serialStream,
        serialPutChar, serialGetChar, _FDEV_SETUP_RW);
    stdout = &serialStream;
    stdin  = &serialStream;
}
\end{lstlisting}

The implementation uses AVR libc's \texttt{fdev\_setup\_stream()} to create a custom \texttt{FILE} stream. The \texttt{serialPutChar()} function writes characters to the UART (used by \texttt{printf}), while \texttt{serialGetChar()} reads characters with local echo and carriage-return-to-newline conversion (used by \texttt{fgets}).

The \texttt{stdioSerialInit()} function performs three essential operations: initializing the UART hardware at the specified baud rate, associating custom I/O functions with a file stream using \texttt{fdev\_setup\_stream()}, and redirecting standard I/O descriptors to this stream. The operational flow is illustrated in \citeimg{fig:flowchart_stdio_setup}.

\begin{figure}[H]
\centering
\includegraphics[width=0.2\textwidth]{resources/Design/ModularImplementation/flowchart_stdio_setup.png}
\caption{Flowchart: Serial STDIO initialization process}
\label{fig:flowchart_stdio_setup}
\end{figure}

Character transmission (\texttt{serialPutChar()}) places data in the UART transmit buffer, as shown in \citeimg{fig:flowchart_stdio_putchar}. The function writes a single character to the serial port and returns immediately after queuing the data.

\begin{figure}[H]
\centering
\includegraphics[width=0.15\textwidth]{resources/Design/ModularImplementation/flowchart_stdio_putchar.png}
\caption{Flowchart: Character transmission to serial port}
\label{fig:flowchart_stdio_putchar}
\end{figure}

Character reception (\texttt{serialGetChar()}) implements blocking read with character echo for user feedback, as depicted in \citeimg{fig:flowchart_stdio_getchar}. The function waits until data becomes available in the receive buffer, reads the character, echoes it back to the terminal for visual confirmation, and returns the received value.

\begin{figure}[H]
\centering
\includegraphics[width=0.55\textwidth]{resources/Design/ModularImplementation/flowchart_stdio_serial.png}
\caption{Flowchart: Character reception from serial port}
\label{fig:flowchart_stdio_getchar}
\end{figure}

This service layer eliminates direct hardware manipulation from application code, enabling portable I/O operations through standard library functions.

\subsubsection{SRV Layer: CommandParser}

The CommandParser module interprets text strings and maps them to command types.

\begin{lstlisting}[language=C++, caption=CommandParser.h --- Command parser interface, label=lst:cmd_parser_h]
#ifndef COMMAND_PARSER_H
#define COMMAND_PARSER_H

enum CommandType {
    CMD_UNKNOWN,
    CMD_LED_ON,
    CMD_LED_OFF
};

CommandType parseCommand(const char *input);

#endif
\end{lstlisting}

\begin{lstlisting}[language=C++, caption=CommandParser.cpp --- Command parser implementation (key sections), label=lst:cmd_parser_cpp]
#include "CommandParser.h"
#include <string.h>
#include <ctype.h>

static void toLowerStr(char *dest,
    const char *src, size_t maxLen) { /* ... */ }

static void trimStr(char *dest,
    const char *src, size_t maxLen) { /* ... */ }

CommandType parseCommand(const char *input) {
    char trimmed[64], lower[64];
    trimStr(trimmed, input, sizeof(trimmed));
    toLowerStr(lower, trimmed, sizeof(lower));

    if (strcmp(lower, "led on") == 0)
        return CMD_LED_ON;
    if (strcmp(lower, "led off") == 0)
        return CMD_LED_OFF;

    return CMD_UNKNOWN;
}
\end{lstlisting}

The parser performs two preprocessing steps (trim whitespace, convert to lowercase) before matching against known commands. This ensures robust handling of user input variations (leading/trailing spaces, mixed case).

\begin{figure}[H]
\centering
\includegraphics[width=0.50\textwidth]{resources/Design/ModularImplementation/flowchart_command_parser.png}
\caption{Functional flowchart of the CommandParser module}
\label{fig:flowchart_command_parser}
\end{figure}

\subsubsection{APP Layer: Lab 1.1 Main}

The application layer ties all modules together:

\begin{lstlisting}[language=C++, caption=lab1\_1\_main.cpp --- Application entry point (key sections), label=lst:lab1_1_main]
#include "lab1_1_main.h"
#include <stdio.h>
#include "Led.h"
#include "StdioSerial.h"
#include "CommandParser.h"

static const uint8_t LED_PIN = 7;
static const unsigned long BAUD_RATE = 9600;
static Led led(LED_PIN);
static char inputBuffer[64];

void lab1_1Setup() {
    stdioSerialInit(BAUD_RATE);
    led.init();
    printf("\r\n=== Lab 1.1: Serial LED Control ===\r\n");
    printf("Commands: led on, led off\r\n");
}

void lab1_1Loop() {
    printf("> ");
    if (fgets(inputBuffer, sizeof(inputBuffer), stdin)) {
        CommandType cmd = parseCommand(inputBuffer);
        switch (cmd) {
            case CMD_LED_ON:
                led.turnOn();
                printf("[OK] LED is now ON.\r\n");
                break;
            case CMD_LED_OFF:
                led.turnOff();
                printf("[OK] LED is now OFF.\r\n");
                break;
            case CMD_UNKNOWN:
                printf("[ERROR] Unknown command.\r\n");
                break;
        }
    }
}
\end{lstlisting}

The application logic is clean and readable: initialize peripherals, then loop over prompt-read-parse-execute-respond. All I/O uses standard C functions (\texttt{printf}, \texttt{fgets}), fulfilling the laboratory requirement.

The module's setup function establishes the execution environment by initializing dependencies in proper order: serial communication first (enabling \texttt{printf}/\texttt{fgets}), then LED hardware. The main loop implements the command processing algorithm whose operational flow and detailed step-by-step execution were thoroughly described in \citeimg{fig:flowchart_main_loop}. The implementation uses standard library functions for I/O operations and the Led class interface for hardware control, maintaining complete independence from hardware-specific details.

This architectural approach ensures that hardware modifications propagate only to the relevant abstraction layer---changing LED pin assignments requires only modifying the constructor argument, while replacing the serial interface would affect only \texttt{StdioSerial}. The application layer remains entirely unaffected by such changes, demonstrating the power of proper abstraction boundaries.
