\section{Conclusion}

\subsection{Achievement of Objectives}

All primary objectives of Laboratory Work 1.1 were successfully accomplished. The UART protocol was used to establish bidirectional text communication between the Arduino Mega 2560 and a host PC, demonstrating fundamental concepts of asynchronous serial communication including baud rate configuration, character transmission/reception, and echo handling. The C standard I/O library was successfully integrated into the embedded application through custom stream redirection, with \texttt{printf()} handling all text output (prompts, confirmations, error messages) and \texttt{fgets()} handling line-based input from the user. The AVR libc \texttt{fdev\_setup\_stream()} mechanism provided the bridge between portable C I/O and the hardware UART. A robust command parser was implemented that correctly interprets \texttt{led on} and \texttt{led off} commands with case-insensitive matching and whitespace tolerance, handling unknown commands gracefully with informative error messages. Finally, the application was decomposed into four independent modules (Led, StdioSerial, CommandParser, lab1\_1\_main), each with clear interfaces and separated concerns, making the library modules fully reusable in future laboratory work.

\subsection{Performance Analysis and System Limitations}

The system demonstrates strong performance characteristics. It responds to commands within milliseconds, well below human-perceptible latency. The memory footprint is minimal, with approximately 64 bytes for the input buffer and small stack allocations in the parser. The compiled firmware occupies only a small fraction of the ATmega2560's 256 KB Flash and 8 KB SRAM resources.

However, the system has several notable limitations. The most significant architectural limitation is the use of blocking I/O: the \texttt{fgets()} call blocks the main loop while waiting for serial input, preventing the MCU from performing other tasks during this time, such as reading sensors, updating displays, or running timers. The system only supports simple on/off commands, with no support for brightness control (PWM), blinking patterns, or status queries. Currently, only a single LED is controlled; extending to multiple LEDs would require parser modifications and additional LED instances. Additionally, the system has no persistent stateâ€”the LED state is lost on reset with no EEPROM storage for the last configuration. The baud rate (9600) is hardcoded and cannot be changed at runtime.

\subsection{Proposed Improvements}

Several enhancements could address the current limitations. Non-blocking I/O should replace the blocking \texttt{fgets()} approach by implementing character-by-character buffering in the main loop, allowing the MCU to service other peripherals between incoming characters. The command set could be extended to support additional commands such as \texttt{led toggle}, \texttt{led status}, \texttt{led blink <rate>}, or PWM-based \texttt{led brightness <0-255>}. The system could support multiple peripherals by extending the parser to control multiple LEDs, buttons, or other actuators by adding device identifiers to commands (e.g., \texttt{led1 on}, \texttt{led2 off}). Configuration persistence could be added by storing the last LED state in EEPROM to restore it after power cycling. A \texttt{help} command could be implemented to dynamically list all available commands and their descriptions. Finally, a simple command buffer could be added to allow the user to recall and re-execute previous commands.

\subsection{Reflections on the Learning Experience}

This laboratory work provided hands-on experience with several foundational concepts in embedded systems development. Understanding how the portable C I/O library can be adapted to work with microcontroller peripherals through custom stream implementations was a key insight, since this technique is widely used in professional embedded firmware for logging and debugging. Separating the application into distinct layers (driver, abstraction, service, application) required disciplined design thinking, and the resulting code is clean, testable, and reusable. Even a simple text-based command interface requires careful attention to user experience: echo, prompts, error messages, case handling, and whitespace tolerance all contribute to a usable system. Using Wokwi to test the application before physical deployment accelerated the development cycle and reduced the risk of hardware damage from wiring errors.

\subsection{Impact of Technology in Real-World Applications}

The serial command interface pattern demonstrated in this lab is directly applicable to numerous real-world embedded systems. Industrial automation systems such as SCADA and PLCs use serial protocols (RS-232, RS-485) for device configuration and monitoring, with text-based command structures similar to MODBUS ASCII or proprietary diagnostic interfaces. Many IoT and smart home devices provide serial debug consoles for firmware updates, Wi-Fi configuration, and troubleshooting; the ESP32, for example, uses a serial AT command interface for its Wi-Fi module. The OBD-II automotive standard includes serial-based diagnostic protocols for reading engine parameters and clearing fault codes. Medical devices employ serial interfaces for device calibration, data logging, and maintenance access in medical instrumentation. Mission-critical aerospace and defense systems use serial command interfaces for ground station communication and satellite command/telemetry links.

The modular software architecture employed in this lab (separation of drivers, services, and application logic) reflects industry best practices codified in standards such as AUTOSAR (AUTomotive Open System ARchitecture) for automotive embedded software.
